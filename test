package com.hexaware.ftp17.model;

import com.hexaware.ftp17.persistence.EmployeeDAO;

import com.hexaware.ftp17.persistence.LeaveDAO;

import static org.junit.Assert.assertEquals;

import static org.junit.Assert.assertNotEquals;

import static org.junit.Assert.assertNull;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNotSame;

import static org.junit.Assert.assertSame;

import org.junit.Before;

import org.junit.Test;

import org.junit.runner.RunWith;

import mockit.Expectations;

import mockit.MockUp;

import mockit.Mocked;

import mockit.Mock;

import mockit.integration.junit4.JMockit;

import java.text.SimpleDateFormat;

import java.text.ParseException;

import java.util.List;

import java.util.ArrayList;

/**
* Test class for Employee.
*/

@RunWith(JMockit.class)

public class EmployeeTest {

  /**
  * setup method.
  */

  @Before

  public void initInput() {

  }

  /**
  * Tests the equals/hashcode methods of the employee class.
  * @throws ParseException if entered date is incorrect.
  */

  @Test

  public final void testEmployee() throws ParseException {

    SimpleDateFormat sf = new SimpleDateFormat("yyyy-MM-dd");

    Employee e100 = new Employee(100, "Ramya", "ram@gmail.com", 9865381512L, sf.parse("2018-01-01"), 0, "HR", 8);

    Employee e101 = new Employee(101, "Sruthi", "sr@gmail.com", 8050071198L, sf.parse("2018-01-01"), 100, "HR", 9);

    assertNotEquals(e100, null);

    assertNotEquals(e100, new Integer(100));

    assertEquals(e100, new Employee(100, "Ramya", "ram@gmail.com", 9865381512L, sf.parse("2018-01-01"), 0, "HR", 8));

    assertNotEquals(e101, new Employee(100));

    assertEquals(e100.hashCode(), new Employee(100, "Ramya", "ram@gmail.com",

        9865381512L, sf.parse("2018-01-01"), 0, "HR", 8).hashCode());

    assertEquals(e100.getEmpId(), new Employee(100).getEmpId());

    assertEquals(e101.getEmpId(), new Employee(101).getEmpId());

    assertEquals(100, e100.getEmpId());

    e101.setEmpId(100);

    assertEquals("Ramya", e100.getEmpName());

    e101.setEmpName("Ramya");

    assertEquals("ram@gmail.com", e100.getEmpEmail());

    e101.setEmpEmail("ram@gmail.com");

    assertEquals(9865381512L, e100.getMobNo());

    e101.setMobNo(9865381512L);

    assertEquals("HR", e100.getDept());

    e101.setDept("HR");

    assertEquals(0, e100.getManagerId());

    e101.setManagerId(0);

    assertEquals(8, e100.getAvlBal());

    e101.setAvlBal(8);

    assertEquals("2018-01-01", sf.format(e100.getDoj()));

    e101.setDoj(sf.parse("2018-01-01"));

    assertEquals(e100, e101);

  }

  /**
  * tests that empty employee list is handled correctly.
  * @param dao mocking the dao class
  */

  @Test

  public final void testListEmpty(@Mocked final EmployeeDAO dao) {

    new Expectations() {

      {

        dao.list();
        result = new ArrayList<Employee>();

      }

    };

    new MockUp<Employee>() {

      @Mock

      EmployeeDAO dao() {

        return dao;

      }

    };

    Employee[] es = Employee.listAll();

    assertEquals(0, es.length);

  }

  /**
  * Tests that a list with some employees is handled correctly.
  * @param dao mocking the dao class
  */

  @Test

  public final void testListAllSome(@Mocked final EmployeeDAO dao) {

    new Expectations() {

      {

        ArrayList<Employee> es = new ArrayList<Employee>();

        es.add(new Employee(1000));

        es.add(new Employee(2000));

        es.add(new Employee(3000));

        dao.list();
        result = es;

      }

    };

    new MockUp<Employee>() {

      @Mock

      EmployeeDAO dao() {

        return dao;

      }

    };

    Employee[] es = Employee.listAll();

    assertEquals(3, es.length);

    assertEquals(new Employee(1000), es[0]);

    assertEquals(new Employee(2000), es[1]);

    assertEquals(new Employee(3000), es[2]);

  }

  /**
  * Tests that a fetch of a specific employee works correctly.
  * @param dao mocking the dao class
  */

  @Test

  public final void testListById(@Mocked final EmployeeDAO dao) {

    final Employee a100 = new Employee(1000);

    final Employee b101 = new Employee(2000);

    final Employee c102 = new Employee(3000);

    new Expectations() {

      {

        dao.find(1000);
        result = a100;

        dao.find(2000);
        result = b101;

        dao.find(3000);
        result = c102;

        dao.find(-1);
        result = null;

      }

    };

    new MockUp<Employee>() {

      @Mock

      EmployeeDAO dao() {

        return dao;

      }

    };

    Employee a = null;

    a = Employee.listById(1000);

    Employee b = null;

    b = Employee.listById(2000);

    Employee c = null;

    c = Employee.listById(3000);

    assertEquals(a100, a);

    assertEquals(b101, b);

    assertEquals(c102, c);

    Employee d = new Employee();

    d = null;

    Employee e = new Employee();

    e = null;

    assertEquals(d, e);

    a = Employee.listById(-1);

    assertNull(a);

    b = Employee.listById(-1);

    assertNull(b);

    c = Employee.listById(-1);

    assertNull(c);

  }

  /**
  * Test to check whether balance updation is happening after approving/denying the leave.
  * @param dao mocking the dao class
  * @throws ParseException if date is invalid.
  */

  @Test

  public final void testAvlBalanceUpdation(@Mocked final EmployeeDAO dao) throws ParseException {

    SimpleDateFormat sf = new SimpleDateFormat("yyyy-MM-dd");

    final Employee e100 = new Employee(100, "Ramya", "ram@gmail.com", 9865381512L, sf.parse("2018-01-01"), 0, "HR", 8);

    new Expectations() {

      {

        dao.avlBalUpdate(4, 100);
        result = 1;

      }

    };

    new MockUp<Employee>() {

      @Mock

      EmployeeDAO dao() {

        return dao;

      }

    };

    int test = Employee.avlBalanceUpdation(4, 100);

    assertEquals(1, test);

  }

  /**
  * Tests the method to find whether entered ID is that of a manager or not works correctly.
  * @param dao mocking the dao class.
  * @throws ParseException for date.
  */

  @Test

  public final void testIsManager(@Mocked final EmployeeDAO dao) throws ParseException {

    new Expectations() {

      {

        SimpleDateFormat ad = new SimpleDateFormat("yyyy/MM/dd");

        ArrayList<Employee> emp = new ArrayList<Employee>();

        ArrayList<Employee> emp1 = new ArrayList<Employee>();

        emp.add(new Employee(100, "Sruthi", "SruthiM@hexaware.com", 913456789, ad.parse("2017/12/27"), 300,

            "HEXAVARSITY", 2));

        emp.add(new Employee(200, "Harish", "HarishR@hexaware.com", 953458789, ad.parse("2017/12/27"), 300,

            "HEXAVARSITY", 4));

        emp1.add(new Employee(101, "Harish", "Hr@hexaware.com", 989456789, ad.parse("2017/12/27"), 301,

            "HEXAVARSITY", 2));

        dao.findManager(300);
        result = emp;

        dao.findManager(301);
        result = emp1;

      }

    };

    new MockUp<Employee>() {

      @Mock

      EmployeeDAO dao() {

        return dao;

      }

    };

    SimpleDateFormat apd = new SimpleDateFormat("yyyy/MM/dd");

    Employee[] em = Employee.isManager(300);

    Employee[] em1 = Employee.isManager(301);

    assertNotEquals(em, null);

    assertEquals(2, em.length);

    assertEquals(1, em1.length);

    assertEquals(new Employee(100, "Sruthi", "SruthiM@hexaware.com", 913456789, apd.parse("2017/12/27"), 300,

        "HEXAVARSITY", 2), em[0]);

    assertEquals(new Employee(200, "Harish", "HarishR@hexaware.com", 953458789, apd.parse("2017/12/27"), 300,

        "HEXAVARSITY", 4), em[1]);

    assertNotEquals(em[0], em[1]);

    assertNotNull(em1[0]);

    assertNotNull(Employee.isManager(301));

  }
/**
 * Tests toString Function.
 * @throws ParseException if the dates are unable to parse.
 */
  @Test

  public final void testToString() throws ParseException {

    SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd");

    Employee e103 = new Employee(1001, "Rohan", "ro2gmail.com", 9898097645L, df.parse("2017-05-25"), 2000,

        "hexavarsity", 10);

    String st = " EmpId:" + e103.getEmpId() + " EmpName:" + e103.getEmpName() + " EmpEmail:" + e103.getEmpEmail()

        + " EmpMobile:" + e103.getMobNo() + "EmpDateOfJoining:" + e103.getDoj() + "EmpManager:" + e103.getManagerId()

        + " EmpDept:" + e103.getDept() + "LeaveAvailable:" + e103.getAvlBal();

    assertEquals(st, e103.toString());

    assertEquals(st, st);

    assertNotEquals(st, e103);

  }

  /**
  * Tests the apply leave method.
  * @throws ParseException if the dates are unable to parse.
  * @param ldao mocking the leave dao object.
  * @param dao mocking the employee dao object.
  */

  @Test

  public final void testapplyLeave(@Mocked final EmployeeDAO dao, @Mocked final LeaveDAO ldao) throws ParseException {

    final SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");

    final LeaveDetails l3000 = new LeaveDetails(1, 2, sdf.parse("2018-01-02"), sdf.parse("2018-01-03"),

        LeaveType.EL, LeaveStatus.PENDING, "sick", sdf.parse("2018-01-01"), "Happy", 7000);

    final List<LeaveDetails> l = new ArrayList<LeaveDetails>();

    l.add(l3000);

    final Employee emp = new Employee(7000, "Sruthi", "SruthiM@hexaware.com", 913456789, sdf.parse("2017-12-27"), 2000,

        "HEXAVARSITY", 20);

    new Expectations() {
      {

        dao.find(7000);
        result = emp;

        ldao.findLeaveHistory(7000);
        result = l;

        ldao.applyLeave(1, sdf.parse("2018-01-09"), sdf.parse("2018-01-09"), "sick", 7000);
        result = 1;

        dao.updateLeaveBal(19, 7000);
        result = 1;

      }

    };

    new MockUp<LeaveDetails>() {

      @Mock

      LeaveDAO ldao() {

        return ldao;

      }

    };

    new MockUp<Employee>() {

      @Mock

      EmployeeDAO dao() {

        return dao;

      }

    };

    assertSame("Successfully applied for leave!",
        Employee.applyLeave(1, sdf.parse("2018-01-09"), sdf.parse("2018-01-09"), "sick", 7000));
    assertNotSame("Sorry!! unable to apply for leave",
        Employee.applyLeave(1, sdf.parse("2018-01-09"), sdf.parse("2018-01-09"), "sick", 7000));

  }

}
